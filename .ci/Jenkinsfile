#!/usr/bin/env groovy
@Library('apm@current') _

pipeline {
  agent { label 'linux && immutable' }
  environment {
    REPO = 'apm-agent-ruby'
    BASE_DIR = "src/github.com/elastic/${env.REPO}"
    PIPELINE_LOG_LEVEL = 'INFO'
    NOTIFY_TO = credentials('notify-to')
    JOB_GCS_BUCKET = credentials('gcs-bucket')
    CODECOV_SECRET = 'secret/apm-team/ci/apm-agent-ruby-codecov'
    DOCKER_REGISTRY = 'docker.elastic.co'
    DOCKER_SECRET = 'secret/apm-team/ci/docker-registry/prod'
    RELEASE_SECRET = 'secret/apm-team/ci/apm-agent-ruby-rubygems-release'
    OPBEANS_REPO = 'opbeans-ruby'
    REFERENCE_REPO = '/var/lib/jenkins/.git-references/apm-agent-ruby.git'
    SLACK_CHANNEL = '#apm-agent-ruby'
  }
  options {
    timeout(time: 2, unit: 'HOURS')
    buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '20', daysToKeepStr: '30'))
    timestamps()
    ansiColor('xterm')
    disableResume()
    durabilityHint('PERFORMANCE_OPTIMIZED')
    rateLimitBuilds(throttle: [count: 60, durationName: 'hour', userBoost: true])
    quietPeriod(10)
  }
  triggers {
    issueCommentTrigger("(${obltGitHubComments()}|^run benchmark tests)")
  }
  parameters {
    booleanParam(name: 'Run_As_Main_Branch', defaultValue: false, description: 'Allow to run any steps on a PR, some steps normally only run on main branch.')
    booleanParam(name: 'bench_ci', defaultValue: true, description: 'Enable run benchmarks.')
  }
  stages {
    /**
    Checkout the code and stash it, to use it on other stages.
    */
    stage('Checkout') {
      options { skipDefaultCheckout() }
      steps {
        pipelineManager([ cancelPreviousRunningBuilds: [ when: 'PR' ] ])
        deleteDir()
        gitCheckout(basedir: "${BASE_DIR}", githubNotifyFirstTimeContributor: true, reference: "${env.REFERENCE_REPO}")
        stash allowEmpty: true, name: 'source', useDefaultExcludes: false
      }
    }
    stage('Benchmarks') {
      options { skipDefaultCheckout() }
      when {
        beforeAgent true
        allOf {
          anyOf {
            branch 'main'
            branch "\\d+\\.\\d+"
            branch "v\\d?"
            tag pattern: 'v\\d+.*', comparator: "REGEXP"
            expression { return params.Run_As_Main_Branch }
            expression { return env.GITHUB_COMMENT?.contains('benchmark tests') }
          }
          expression { return params.bench_ci }
        }
      }
      stages {
        stage('Clean Workspace') {
          agent { label 'microbenchmarks-pool' }
          steps {
            echo "Cleaning Workspace"
          }
          post {
            always {
              cleanWs(notFailBuild: true)
            }
          }
        }
        /**
          Run the benchmarks and store the results on ES.
          The result JSON files are also archive into Jenkins.
        */
        stage('Run Benchmarks') {
          steps {
            withGithubNotify(context: 'Run Benchmarks') {
              deleteDir()
              unstash 'source'
              dir("${BASE_DIR}"){
                script {
                  def versions = readYaml(file: ".ci/.jenkins_ruby.yml")
                  def benchmarkTask = [:]
                  versions['VERSION'].each{ v ->
                    benchmarkTask[v] = runBenchmark(v)
                  }
                  parallel(benchmarkTask)
                }
              }
            }
          }
        }
      }
    }
    stage('Release') {
      options { skipDefaultCheckout() }
      environment {
        RUBY_DOCKER_TAG = 'ruby:2.6'
        HOME = '/var/lib/jenkins'
      }
      when {
        beforeAgent true
        tag pattern: 'v\\d+.*', comparator: 'REGEXP'
      }
      stages {
        stage('Notify') {
          steps {
            notifyStatus(slackStatus: 'warning', subject: "[${env.REPO}] Release *${env.TAG_NAME}* ready to be pushed",
                         body: "(<${env.RUN_DISPLAY_URL}|Open>).\n Changes: ${env.TAG_NAME}")
          }
        }
        stage('Release') {
          steps {
            deleteDir()
            unstash 'source'
            prepareRelease(){
              sh 'rake release'
            }
          }
        }
        stage('Update Branch') {
          steps {
            deleteDir()
            unstash 'source'
            prepareRelease(){
              catchError(buildResult: 'SUCCESS', message: 'Update branch task failed', stageResult: 'UNSTABLE') {
                sh 'rake release:update_branch'
              }
            }
          }
          post {
            success {
              notifyStatus(slackStatus: 'good', subject: "[${env.REPO}] Release *${env.TAG_NAME}* published",
                           body: "Great news, the release has been done successfully. (<${env.RUN_DISPLAY_URL}|Open>).")
            }
            unsuccessful {
              notifyStatus(slackStatus: 'warning', subject: "[${env.REPO}] Release *${env.TAG_NAME}* has some sync-up post-release failures.",
                           body: "Please go to ${env.BUILD_URL} to review the logs. Most likely you need to update the branch manually. (<${env.RUN_DISPLAY_URL}|Open>)")
            }
          }
        }
        stage('Opbeans') {
          environment {
            REPO_NAME = "${OPBEANS_REPO}"
            VERSION = "${env.BRANCH_NAME.replaceAll('^v', '')}"
          }
          steps {
            deleteDir()
            // Let's wait for the Gem to be available
            sh label: 'Wait for gem', script: """#!/usr/bin/env bash
              source /usr/local/bin/bash_standard_lib.sh
              (retry 10 curl --silent --show-error --fail -I https://rubygems.org/gems/elastic-apm/versions/${env.VERSION})
            """
            dir("${OPBEANS_REPO}"){
              git(credentialsId: 'f6c7695a-671e-4f4f-a331-acdce44ff9ba',
                  url: "git@github.com:elastic/${OPBEANS_REPO}.git",
                  branch: 'main')
              // It's required to transform the tag value to the gem version
              sh script: ".ci/bump-version.sh ${env.VERSION}", label: 'Bump version'
              // The opbeans pipeline will trigger a release for the main branch
              gitPush()
              // The opbeans pipeline will trigger a release for the release tag
              gitCreateTag(tag: "${env.BRANCH_NAME}")
            }
          }
        }
      }
    }
  }
  post {
    cleanup {
      notifyBuildResult()
    }
  }
}

/**
  Run benchmarks for a Ruby version, then report the results to the Elasticsearch server.
*/
def runBenchmark(version){
  return {
    node('microbenchmarks-pool'){
      // Transform the versions like:
      //  - docker.elastic.co/observability-ci/jruby:9.2-12-jdk to jruby-9.2-12-jdk
      //  - jruby:9.1 to jruby-9.1
      def transformedVersion = version.replaceAll('.*/', '').replaceAll(':', '-')
      withEnv(["HOME=${env.WORKSPACE}/${transformedVersion}"]){
        dir("${transformedVersion}"){
          deleteDir()
          unstash 'source'
          dir("${BASE_DIR}"){
            retry(2){
              sleep randomNumber(min:10, max: 30)
              dockerLogin(secret: "${DOCKER_SECRET}", registry: "${DOCKER_REGISTRY}")
            }
            try{
              sh """./spec/scripts/benchmarks.sh "${version}" "${REFERENCE_REPO}" """
            } finally {
              archiveArtifacts(
                allowEmptyArchive: true,
                artifacts: "**/benchmark-${transformedVersion}.raw,**/benchmark-${transformedVersion}.error",
                onlyIfSuccessful: false)
              sendBenchmarks(file: "benchmark-${transformedVersion}.bulk",
                index: "benchmark-ruby", archive: true)
              cleanWs(notFailBuild: true)
            }
          }
        }
      }
    }
  }
}

def prepareRelease(Closure body){
  dir("${env.BASE_DIR}"){
    docker.image("${env.RUBY_DOCKER_TAG}").inside('-v ${REFERENCE_REPO}:${REFERENCE_REPO} -v /etc/passwd:/etc/passwd -v ${HOME}/.ssh:${HOME}/.ssh') {
      withEnv(["HOME=${env.WORKSPACE}/${env.BASE_DIR ?: ''}"]) {
        rubygemsLogin.withApi(secret: "${env.RELEASE_SECRET}") {
          withGitRelease(credentialsId: '2a9602aa-ab9f-4e52-baf3-b71ca88469c7-UserAndToken') {
            sh 'gem install rake yard rspec'
            body()
          }
        }
      }
    }
  }
}

// Transform the versions like:
//  - docker.elastic.co/observability-ci/jruby:9.2-12-jdk to jruby-9.2-12-jdk
//  - jruby:9.1 to jruby-9.1
def normalise(def what) {
  return what.replaceAll('.*/', '').replaceAll(':', '-')
}

def notifyStatus(def args = [:]) {
  releaseNotification(slackChannel: "${env.SLACK_CHANNEL}",
                      slackColor: args.slackStatus,
                      slackCredentialsId: 'jenkins-slack-integration-token',
                      to: "${env.NOTIFY_TO}",
                      subject: args.subject,
                      body: args.body)
}
